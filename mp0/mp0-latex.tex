\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{times}
\usepackage{amsmath,amsfonts,amssymb,amsthm,commath,dsfont}
\usepackage[colorlinks,urlcolor=blue]{hyperref}
\usepackage{xcolor}

\def\ddefloop#1{\ifx\ddefloop#1\else\ddef{#1}\expandafter\ddefloop\fi}
\def\ddef#1{\expandafter\def\csname b#1\endcsname{\ensuremath{\mathbb{#1}}}}
\ddefloop ABCDEFGHIJKLMNOPQRSTUVWXYZ\ddefloop
\def\ddef#1{\expandafter\def\csname c#1\endcsname{\ensuremath{\mathcal{#1}}}}
\ddefloop ABCDEFGHIJKLMNOPQRSTUVWXYZ\ddefloop

\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\softmax}{softmax}

\def\pts#1{\textbf{[#1 pts]}}
\def\vx{\mathbf{x}}
\def\vy{\mathbf{y}}
\def\vz{\mathbf{z}}
\def\vw{\mathbf{w}}

\newenvironment{Q}{\clearpage \item}{\phantom{s} \bigskip}
\newenvironment{Solution}{\color{blue}\begin{enumerate}}{\end{enumerate}}

\urlstyle{same}

\title{\LARGE ECE549 / CS543 Computer Vision: Assignment 0}
\date{}

\begin{document}
\maketitle
\subsection*{Instructions}
\begin{enumerate}
  \item Assignment is due at \textbf{11:59:59 PM on Monday Feb 3 2020}.
  \item Course policies: \url{http://saurabhg.web.illinois.edu/teaching/ece549/sp2020/policies.html}.
  \item Submission instructions:
  \begin{enumerate}
      \item A single \texttt{.pdf} report that contains your work for Q1, Q2 and Q3. For Q1 and Q2 you can type out your responses in the space provided on pages 2 and 3 (directly on PDF, or via \LaTeX{}). Alternatively, you can also print pages 2 and 3, respond by handwriting your responses in the space provided, and scan the pages into a PDF. For Q3 your response should be electronic (no handwritten responses allowed). You should respond to the questions 3(a), 3(b), 3(c) and 3(d) individually and include images as necessary. Your response to Q3 in the PDF report should be self-contained. It should include all the output you want us to look at. You will not receive credit for any results you have obtained, but failed to include directly in the PDF report file. PDF file will need to be submitted to \url{https://www.gradescope.com} (Entry Code: \textbf{MVZDNW}), and you will need to tag your PDF with where your response to each of the question is.
      \item You also need to submit code for Q3 in the form of a single \texttt{.zip} file that includes all your code, all in the same directory. You can submit Python code in either \texttt{.py} or \texttt{.ipynb} format. Code will need to be submitted to compass2g.
      \item The \LaTeX{} source is available:  \url{http://saurabhg.web.illinois.edu/teaching/ece549/sp2020/mp/mp0-latex.tex}.
      \item We reserve the right to take off points for not following submission instructions.
  \end{enumerate}
\end{enumerate}

\subsection*{Change log}
{
\renewcommand{\arraystretch}{1.5}
\begin{tabular}{llp{5in}}
   v1 & 01/27/2020 & 
     Add Gradescope code; Add link to \LaTeX{} source; Finalized submission instructions; \newline
     1(a), explicitly write the all-one vector, add link to exp-normalize-trick description;\\
   \href{http://saurabhg.web.illinois.edu/teaching/ece549/sp2020/mp/mp0-v0.pdf}{v0} & 01/22/2020 & Creation.
\end{tabular}
}

\begin{enumerate}

%% Q1
\begin{Q}
\textbf{Calculus Review \pts{10}.}

The $\softmax$ function is a commonly-used operator which turns a vector into a valid probability distribution, i.e. non-negative and sums to 1.
    
For vector $\vz = (z_1, z_2, \ldots, z_k) \in \bR^k $, the output $\vy = \softmax(\vz) \in \bR^k$, and its $i$-th element is defined as 
\begin{equation}
    y_i = \softmax(\vz)_i = \frac{ \exp(z_i) }{ \sum_{j=1}^k \exp(z_j) } .
\end{equation}

\begin{enumerate}
    \item \pts3
    Verify that $\softmax(\vz)$ is invariant to constant shifting on $\vz$, i.e. $\softmax(\vz) = \softmax(\vz + C\mathbf{1})$ where $C \in \bR$ and $\mathbf{1}$ is the all-one vector. The $\softmax(\vz - \max_j z_j)$ \href{https://timvieira.github.io/blog/post/2014/02/11/exp-normalize-trick/}{trick} is used in deep learning packages to avoid numerical overflow.
    
    %% Your answer for 1(a) here
    \vspace{3cm}
    %%
    
    \item \pts3
    Let $y_i = \softmax(\vz)_i, 1\le i\le k$. Compute the derivative
    $ \frac{\partial y_i}{\partial z_j} $ for any $i,j$.
    Your result should be as simple as possible, and may contain elements of $\vy$ and/or $\vz$.
    
    %% Your answer for 1(a) here
    \vspace{5cm}
    %%
    
    \item \pts4
    Consider $\vz$ to be the output of a linear transformation
    $ \vz = W^\top \vx $, where vector $ \vx \in \bR^d $ and matrix $ W \in \bR^{d \times k} $. 
    Denote $ \{ \vw_1, \vw_2, \ldots, \vw_k \}$ as the columns of $W$. Let $\vy = \softmax(\vz) $.
    Compute $ \frac{\partial y_i}{\partial \vx} $ and $ \frac{\partial y_i}{\partial \vw_j} $. 
    (Hint: You may reuse (b) and apply the chain rule. 
    Vector derivatives: $ \frac{\partial (\mathbf{a} \cdot \mathbf{b}) }{\partial \mathbf{a} } = \mathbf{b} $, $ \frac{\partial (\mathbf{a} \cdot \mathbf{b}) }{\partial \mathbf{b} } = \mathbf{a} $ .)
    
    %% Your answer for 1(a) here
    \vspace{3cm}
    %%
\end{enumerate}
  
\end{Q}



%% Q2
\begin{Q}
\textbf{Linear Algebra Review \pts{10}.}

\begin{enumerate}
    \item \pts2
    Let
    $V = 
    \begin{bmatrix}
        \frac1{\sqrt 2} & \frac1{\sqrt 2} \\
        -\frac1{\sqrt 2} & \frac1{\sqrt 2}
    \end{bmatrix} .$
    Compute $ V\begin{bmatrix} 1 \\ 0 \end{bmatrix}$, $ V\begin{bmatrix} 0 \\ 1 \end{bmatrix}$.
    What does matrix multiplication $Vx$ do to $x$?
    
    %% Your answer for 2(a) here
    \vspace{3cm}
    %%
    
    \item \pts2
    Verify that $V^{-1} = V^\top$. What does $V^\top x$ do?
    
    %% Your answer for 2(b) here
    \vspace{3cm}
    %%
    
    \item \pts2
    Let
    $\Sigma = 
    \begin{bmatrix}
        \sqrt{3} & 0 \\
        0 & 1
    \end{bmatrix} .$
    Compute $\Sigma V^\top x$ where $x = \begin{bmatrix} \sqrt{2} \\ 0 \end{bmatrix}, 
    \begin{bmatrix} 0 \\ \sqrt{2} \end{bmatrix}, 
    \begin{bmatrix} -\sqrt{2} \\ 0 \end{bmatrix}, 
    \begin{bmatrix} 0 \\ -\sqrt{2} \end{bmatrix}$ respectively. 
    These are 4 corners of a square. What is the shape of the result points? 
    
    %% Your answer for 2(c) here
    \vspace{3cm}
    %%
    
    \item \pts2
    Let
    $U = 
    \begin{bmatrix}
         \frac{1}2 & -\frac{\sqrt{3}}2 \\
        \frac{\sqrt{3}}2 & \frac{1}2
    \end{bmatrix} .$
    What does $Ux$ do? (\href{https://en.wikipedia.org/wiki/Rotation_matrix}{Rotation matrix wiki})
    
    %% Your answer for 2(d) here
    \vspace{3cm}
    %%
    
    \item \pts2
    Compute $A = U\Sigma V^T$. From the above questions, we can see a geometric interpretation of $Ax$: (1) $V^T$ first rotates point $x$, (2) $\Sigma$ rescales it along the coordinate axes, (3) then $U$ rotates it again.
    Now consider a general squared matrix $B \in \bR^{n\times n}$.
    How would you obtain a similar geometric interpretation for $Bx$?
    
    %% Your answer for 2(e) here
    %\vspace{3cm}
    %%
\end{enumerate}

\end{Q} % end Q2



%% Q3
\begin{Q}
\textbf{Colorizing Prokudin-Gorskii images of the Russian Empire.\footnote{This assignment was originally designed by Alexei Efros. This version is adapted from adaptations by David Fouhey, and Svetlana Lazebnik.} \pts{50}}

\href{https://en.wikipedia.org/wiki/Sergey_Prokudin-Gorsky}{\color{blue}Sergei Mikhailovich Prokudin-Gorskii} (1863-1944) was a photographer who, between the years 1909-1915, traveled the Russian empire and took thousands of photos of everything he saw. He used an early color technology that involved recording three exposures of every scene onto a glass plate using a red, green, and blue filter. Back then, there was no way to print such photos, and they had to be displayed using a special projector. Prokudin-Gorskii left Russia in 1918. His glass plate negatives survived and were purchased by the Library of Congress in 1948. Today, a digitized version of the Prokudin-Gorskii collection is available \href{http://www.loc.gov/exhibits/empire/gorskii.html}{\color{blue}online}. 

The goal of this assignment is to learn to work with images by taking the digitized Prokudin-Gorskii glass plate images and automatically producing a color image with as few visual artifacts as possible. In order to do this, you will need to extract the three color channel images, place them on top of each other, and align them so that they form a single RGB color image. 

Prokudin-Gorskii's black-and-white (grayscale) image composites, and some other test images are available at \url{http://saurabhg.web.illinois.edu/teaching/ece549/sp2020/mp/mp0-data.tgz}. Note that the filter order from top to bottom is BGR, not RGB.

\begin{enumerate}
    \item \textbf{Combine \pts{5}.} Choose a single image from the \texttt{prokudin-gorskii} folder (your favorite) and write a program in Python that first divides the image into three equal parts (channels), and takes the three grayscale channels and simply stacks them across the third color channel dimension to produce a single, colored image. We expect this stacked photo to look wonky and unaligned -- fixing this is what you will do in the next parts.
    Save this generated image. Make sure to save your image with the correct channel ordering (it varies depending on what library you are using to save images from Python).
    \textbf{Include the generated image into your report.} 
    
    \item \textbf{Align \pts{25}.} As you will have noticed, the photos are misaligned due to inadvertent jostling of the camera between each shot. Your second task is to fix this. You need to search over possible pixel offsets in the range of [-15, 15] to find the best alignment for the different R, G, and B channels. The simplest way is to keep one channel fixed, say R, and search over horizontal and vertical offsets that align the G and the B channels to the R channel. Pick the offset that maximizes a similarity metric (of your choice) between the channels. 
    You can measure similarity using (negative of) the \textit{sum of squared differences} which is simply the L2 norm of the pixel difference between the two channels. You can also use \textit{zero mean normalized cross correlation}, which is simply the dot product between the two channels after they have been normalized to have zero mean and unit norm. 
    After writing this function, run it on all of the images in the \texttt{prokudin-gorskii} folder. Find a similarity metric that aligns all these images.
    \textbf{Save the newly aligned images in your report, along with the offsets for each color channel. 
    Also include a brief description of your implemented solution, focusing especially on the more non-trivial or interesting parts of the solution. What design choices did you make, and how did they affect the quality of the result and the speed of computation? What are some artifacts and/or limitations of your implementation, and what are possible reasons for them?}
    \textbf{Hint:} To offset the channels while keeping the same dimensions among them, you can use either \texttt{np.roll()} to roll over boundaries, or \texttt{np.pad()} for padding.
    
    \item \textbf{Fast Align \pts{20}.} For very large offsets (and high resolution images), comparing all the alignments for a broad range of displacements (e.g. [-30, 30]) can be computationally intensive. We will have you implement a recursive version of your algorithm that starts by estimating an image's alignment on a low-resolution version of itself, before refining it on higher resolutions. To implement this, you will build a two-level image pyramid. To do this, you must first scale the triple-frame images down by a factor of 2 (both the width and height should end up halved). Starting with your shrunk, coarse images, execute your alignment from part (b) over the [-15, 15] offset range. Choose the best alignment based on your similarity metric and treat it as the new current alignment. Then in the full resolution images, use this new current alignment as a starting place to again run the alignment from part (b) in the small offset range of [-15, 15]. Run this faster alignment on the \texttt{seoul\_tableau.jpg} and \texttt{vancouver\_tableau.jpg} images. 
    \textbf{Report the intermediate offset (at the coarse resolution), the next offset at the full resolution, and what the overall total offset was that includes both of these. Also include the aligned images in color in your report.} 
    \textbf{Hint:} If you’re struggling, use a different color channel as your anchor!
    
    \item \textbf{Extra Credit \pts{Upto 10}.} Implement and test any additional ideas you may have for improving the speed or quality of the colorized images. For example, the borders of the photograph will have strange colors since the three channels won't exactly align. See if you can devise an automatic way of cropping the border to get rid of the bad stuff. One possible idea is that the information in the good parts of the image generally agrees across the color channels, whereas at borders it does not. 
    \textbf{In your report describe the improvements you made, include images (if you improved the quality) and supporting metrics (if you improved the speed). You should provide enough implementation details about how you made these improvements.}
\end{enumerate}

\end{Q} % end Q3


\end{enumerate} % end Q

\end{document}
